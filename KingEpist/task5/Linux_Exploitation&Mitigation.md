# part1
## elf 동적 디버깅
* elf 동적 분석 도구
  * gdb
  * strace
  * ltrace
  * ida
  여기서는 gdb를 통해 동적 디버깅
* gdb 디스어셈블리 문법
  * intel
  * AT&T
  * 기본 설정은 AT&T로 되어 있으나 여기선 intel을 사용할 것
  * intel로 설정 바꾼느 방법
    * .gdbinit은 gdb를 시작할 때 자동적으로 실행할 gdb 명령어들을 저장하고 있는 명령어
    * 
    ~~~
    $ echo "set disassembly-flavor intel" >> ~/.gdbinit
    ~~~
    .gdbinit에 gdb의 디스어셈블리 법을 intel로 바꾸어 주는 명령어
* disassamble 명령어는 gdb에서 하무의 디스어셈블리 결과를 출력해주는 명령어
* b 또는 breakpoint 명령어로 breakpoint를 설정가능
* info break 명령어로 breakpoint가 잘 설정되었는지 확인가능
* run(r) 명령어를 실행하면 breakpoint에서 멈추게 되고 info register(reg)로 확인해보면 eip 값이 breakpoint를 건 주소값이 된 것을 확인 가능
* print(p) 명령어로 레지스터나 변수의 값을 출력시키는 것이 가능
* x 명령어를 사용하면 인자로 주어진 주소의 메모리를 볼 수 있음. 출력 타입을 정해줄 수 있음
  * ex) x/2wx $esp //esp 레지스터의 메모리를 word 타입으로 2개만큼 출력
* 위의 경우에 printf 함수가 호출되는 시점의 parameter들이 순서대로 저장되어 있는 것을 확인 가능
* printf 함수의 경우 첫번째 parameter가 parameter이므로 x/s <얻은 첫번째 주소>를 넣으면 string을 확인
* gdb에 -p PID 또는 --pid=PID를 인자로 전달하면 PID에 해당하는 프로세스에 gdb를 attach 가능
*
~~~
$ ps -aux | grep read_write
~~~
첫번째 방법은 (여기서는 read)Write)바이너리를 실행한 뒤에 위의 명령어로 PID를 구할 수 있음
* 
~~~
$ pidof read_write
50353
$ pgrep read_write
50353
~~~
두번째 방법은 pidof나 pgrep 프로그램을 통해 프로세스의 pid를 구하는 것(위와 같이)
* 
~~~
# gdb -q -p 50353
~~~
위에서 구한 process 값들을 가지고 gdb를 프로세스에 attach할 수 있음
